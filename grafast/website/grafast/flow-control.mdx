---
title: "Flow control"
sidebar_position: 6
---

import Mermaid from "@theme/Mermaid";

# Flow control

Gra*fast* plans are declarative graphs. An operation plan is constructed the
first time Gra*fast* sees a particular operation, and that same plan is then
reused for every compatible request. Each step in the plan describes where a
value comes from and how it should be transformed, and these steps form a
directed acyclic graph (DAG) starting from the inputs of the request (variables,
arguments, context, etc) and flowing all the way down to be consumed by the
output plan.

There is no imperative branching inside the plan. Instead, values flow along the
dependency edges until a step raises an error, signals inhibition, meets a
"layer plan" boundary (e.g. a null check, or polymorphic position), or passes
them onwards to be consumed by the output plan.

:::note[Think in batches]

Gra*fast* executes each step in a plan diagram just once for every request, even
if that step is handling hundreds or thousands of list values. For every
dependency a step has, Gra*fast* takes the "execution value" that represents the
list of values for that step, filters out the entries that were inhibited or
errored (by that dependency, or by any of the other dependencies of the same
step), then passes the remaining values (if any) on to the dependent step for
execution. Finally it remaps the results back to their
original indices.

When a list position is encountered the batch expands via a new list Layer Plan:
an `__ItemStep` is populated with the list items and the data then flows from
this point onwards with the larger batch size.

If a single element within that batch is inhibited or errors, only that element
is skipped; the rest continue through the graph.

:::

## Unary steps ("global dependencies")

The entrypoints to our graph, our operation plan, are the request values: the
variables, static arguments, context, constants, and similar concerns. Each of
these represent exactly one value per request, and thus they have a batch size
of `1`. We add them all automatically to the "root" layer plan, which will also
always have a batch size of `1`.

Steps that depend on only these steps directly (and do not occur after any side
effect steps) will also typically execute with a batch size of `1`. Similarly
for steps that depend only on these!

We call steps that Gra*fast* can prove will always have a batch size of 1,
"unary steps", and we'll often mark them as such using the `➊` character in the
plan diagram:

<Mermaid chart={`
flowchart TD
  Object{{"Object[11∈0] ➊<br />ᐸ{ ... }ᐳ"}}:::plan
`} />

Some steps may need one or more of their dependencies to only have a single
value shared across the entire batch — for example a database connection
retrieved from the context. They can add this as a requirement by ensuring the
step is added as a "unary dependency" via `this.addUnaryDependency($step)`:

```ts
const $db = context().get("db");
const $row = loadOne($id, {
  shared: $db,
  load: async (ids, { shared: db }) => db.getUsersByIds(ids)
})
```
Here, even though `$id` might represent hundreds of values when evaluated inside
a list, `context()` and thus `context().get("db")` will only ever represent a
single value - a unary value - and thus the same `db` client can be shared across
the entire list of `ids` at runtime.

## Why "branching" feels different

A common question is how to express logic such as "if X then load Y otherwise
load Z", but Gra*fast* does not exist to perform such logic - it is not a
programming language, but a system that plans and optimizes the flow of data.

A field plan must return exactly one step, and that step must represent data of
the expected return type. The decision as to which specific `Post` a field
resolver should return (whether the English translation or the German one, for
example) belongs inside the relevant single step that loads the `Post`, or maybe
one of its dependencies.

**All procedural and business logic happens inside the steps' `execute()`
methods, not in plans.**

:::note[Step execute methods should delegate to business logic]

It's intended the step execute methods are generally lightweight if possible -
they act as the gateway between Gra*fast*-land and your business logic; they are
not typically for actually performing business logic directly, instead they
should delegate to external business logic.

:::

## Early exit

Though Gra*fast* doesn't support traditional branching, it does recognize that
there are common "early exit" needs within the flow of data. Perhaps if a value
is `null` then there's no need to continue. When an error occurs, of course
processing should halt. Gra*fast* therefore gives you the tools to indicate when
field plans should "exit early" by selectively inhibiting nulls with
[`inhibitOnNull`](./step-library/standard-steps/inhibitOnNull.mdx) (or by
returning the special `$$inhibit` value), or by raising errors from within your
steps. 

Here we only proceed to loading the user if the given ID is non-null:

```ts
const $guardedId = inhibitOnNull($id);
const $user = loadOne($guardedId, batchGetUserById);
return $user;
```

<Mermaid chart={`
flowchart TD
  ID["Access<'id'>"] --> Guard["inhibitOnNull"]
  Guard --> Load["loadOne"]
`}/>

Gra*fast* distinguishes between a value that is literally `null` and a value
that has been **inhibited**. An inhibited value tells the executor that it may
skip the following work that depends on that input. This keeps plans efficient
when a primary key or foreign key is absent, or when guard conditions fail.

- [`inhibitOnNull`](./step-library/standard-steps/inhibitOnNull.mdx) prevents
  dependents from executing when its dependency resolves to `null`, having them
  resolve to `null` too.
- [`assertNotNull`](./step-library/standard-steps/assertNotNull.mdx) upgrades a
  `null` into a `SafeError`, preventing downstream work and surfacing an
  execution error instead.
- [`trap`](./step-library/standard-steps/trap.mdx) converts inhibited or errored
  values back into ordinary data so execution can resume.

These helpers all wrap the same underlying `__FlagStep`. Most of the time the
step is absorbed into the dependency edge, so plan diagrams display labels such
as `rejectNull`, `trapError`, or `onReject="…"` rather than a distinct node.

When only one entry in a batch is inhibited or errored, only that entry is
skipped; other entries continue to flow through the dependent steps. Gra*fast*
handles this itself, the inhibited or errored values will simply never be passed
to the execute methods of your step classes.

## Putting it together

The helpers above are building blocks. A typical pattern is to guard an input,
inhibit downstream work when it is missing, and optionally trap that inhibition
later so the field can return a benign value. Viewed as data flow:

<Mermaid chart={`
flowchart TD
  Input["specFromNodeId"] --> Guard["inhibitOnNull"]
  Guard -->|rejectNull| Fetch["loadMany"]
  Fetch --> Recover["trap (trapInhibited→EMPTY_LIST)"]
  Recover --> Output["Field return value"]
`}/>

Once you approach plans through that lens — values in, values optionally
flagged, values out — Gra*fast*'s "early exit" behaviour becomes a natural
consequence of the data dependencies rather than an imperative control-flow
construct.

For more about the individual helpers, see the
[flow control steps](./step-library/standard-steps/index.mdx#flow-control) and
the [plan diagram guide](./plan-diagrams.mdx) for visual cues.
