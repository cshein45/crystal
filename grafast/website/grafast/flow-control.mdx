---
title: "Flow control"
sidebar_position: 6
---

import Mermaid from "@theme/Mermaid";

# Flow control

Gra*fast* plans are declarative graphs. An operation plan is constructed the
first time Gra*fast* sees a particular operation, and that same plan is then
reused for every compatible request. Each step in the plan describes where a
value comes from and how it should be transformed, and these steps form a
directed acyclic graph (DAG) starting from the inputs of the request (variables,
arguments, context, etc) and flowing all the way down to be consumed by the
output plan.

There is no imperative branching inside the plan. Instead, values flow along the
dependency edges until a step raises an error, signals inhibition, meets a
"layer plan" boundary (e.g. a null check, or polymorphic position), or passes
them onwards to be consumed by the output plan.

:::note[Think in batches]

Gra*fast* executes each step in a plan diagram just once for every request, even
if that step is handling hundreds or thousands of list values. For every
dependency a step has, Gra*fast* takes the "execution value" that represents the
list of values for that step, filters out the entries that were inhibited or
errored (by that dependency, or by any of the other dependencies of the same
step), then passes the remaining values (if any) on to the dependent step for
execution. Finally it remaps the results back to their
original indices.

When a list position is encountered the batch expands via a new list Layer Plan:
an `__ItemStep` is populated with the list items and the data then flows from
this point onwards with the larger batch size.

If a single element within that batch is inhibited or errors, only that element
is skipped; the rest continue through the graph.

:::

## Why "branching" feels different

A common question is how to express logic such as "if X then load Y". The plan
already contains every helper step up front; the conditional behaviour lives
_inside_ those steps. They can evaluate predicates via
[`condition`](./step-library/standard-steps/condition.md), selectively inhibit
values with [`inhibitOnNull`](./step-library/standard-steps/inhibitOnNull.mdx),
combine alternatives with
[`coalesce`](./step-library/standard-steps/coalesce.md), and so on. A field plan
still returns exactly one step, but that step can depend on other steps that
decide which values survive the journey.

```ts
const $shouldLoad = condition("not null", $id);
const $guardedId = inhibitOnNull($id, { if: $shouldLoad });
const $user = loadOne($guardedId, batchGetUserById);
return $user;
```

All three helper steps remain in the plan for every future execution. At runtime
any entry where `$shouldLoad` is false marks the corresponding `$guardedId` as
inhibited, and `loadOne` simply skips that entry while continuing with the rest
of the batch.

<Mermaid chart={`
flowchart TD
  ID["Access('id')"] --> Should["condition('not null', …)"]
  ID --> Guard["inhibitOnNull (if=Should)"]
  Should --> Guard
  Guard --> Load["loadOne"]
`}/>

## Inhibition and "early exit"

Gra*fast* distinguishes between a value that is literally `null` and a value
that has been **inhibited**. An inhibited value tells the scheduler that it may
skip derived work that depends on that input. This keeps plans efficient when a
primary key or foreign key is absent, or when guard conditions fail.

- [`inhibitOnNull`](./step-library/standard-steps/inhibitOnNull.mdx) rejects the
  `NULL` flag when its dependency resolves to `null`.
- [`assertNotNull`](./step-library/standard-steps/assertNotNull.mdx) upgrades a
  `null` into a `SafeError`, preventing downstream work and surfacing an
  execution error instead.
- [`trap`](./step-library/standard-steps/trap.mdx) converts inhibited or errored
  values back into ordinary data so execution can continue.

These helpers all wrap the same underlying `__FlagStep`. Most of the time the
step is absorbed into the dependency edge, so plan diagrams display labels such
as `rejectNull`, `trapError`, or `onReject="…"` rather than a distinct node.
When only one entry in a batch is inhibited or errored, only that entry is
skipped; other entries continue to flow through the dependent steps.

## Global dependencies

Some steps need values that apply to the whole request — for example GraphQL
variables, the `contextValue`, or a database connection retrieved from the
context. Gra*fast* refers to these as **global dependencies** and they are added
as unary dependencies: the dependency supplies a single value that each item in
the batch can read.

```ts
const $context = context();
const $db = $context.get("pg");
const $row = loadOne($id, ({ batch }) => batchFetch(db, batch));
```

Because the context does not vary per item, Gra*fast* does not duplicate work.
Plan diagrams may elide the arrow when it would otherwise be drawn many times;
the actual execution plan still tracks the relationship.

## Putting it together

The helpers above are building blocks. A typical pattern is to guard an input,
inhibit downstream work when it is missing, and optionally trap that inhibition
later so the field can return a benign value. Viewed as data flow:

<Mermaid chart={`
flowchart TD
  Input["specFromNodeId"] --> Guard["inhibitOnNull"]
  Guard -->|rejectNull| Fetch["loadMany"]
  Fetch --> Recover["trap (trapInhibited→EMPTY_LIST)"]
  Recover --> Output["Field return value"]
`}/>

Once you approach plans through that lens — values in, values optionally
flagged, values out — Gra*fast*'s "early exit" behaviour becomes a natural
consequence of the data dependencies rather than an imperative control-flow
construct.

For more about the individual helpers, see the
[flow control steps](./step-library/standard-steps/index.mdx#flow-control) and
the [plan diagram guide](./plan-diagrams.mdx) for visual cues.
