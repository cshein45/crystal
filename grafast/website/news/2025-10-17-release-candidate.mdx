---
title: Grafast v1 reaches release candidate stage
description:
  Grafast v1 is functionally complete and powering production workloads, now
  we need your help to finish the docs ahead of the 1.0 final.
slug: 2025-10-17-grafast-v1-release-candidate
authors: [benjie, jem]
tags: [0.1, RC]
hide_table_of_contents: false
toc_max_heading_level: 2
---

import styles from "@site/src/css/common.module.css";

<div className={styles.intro}>

The Gra*fast* v1.0 release candidate is now available. The engine has stabilized, the
epic milestones are complete, and the runtime has been hardened by more than a year of
production use through PostGraphile V5 and standalone adopters. All that
remains is to finish the documentation and tighten the TypeScript experience.

</div>

## From working group sketches to a stable execution engine

We debuted Gra*fast* in 2020 as an answer to the limits of resolver-driven
execution. The working group crystallized a plan-first mental model: every field
should describe the graph of steps it requires, and the planner is responsible
for weaving those graphs into a reusable dataflow that the runtime can execute
efficiently. Four epics stood between that vision and a stable 1.0:

- ✅ **Global dependencies**: we rewrote the planning
  infrastructure so shared inputs (like database connections) are explicitly
  marked as unary. Plan diagrams now make it obvious when a value is reused
  across the batch, and the engine can enforce those guarantees automatically.
- ✅ **Early exit controls**: instead of scattering manual branching
  logic through plan resolvers, Gra*fast* now propagates inhibition flags along
  the dataflow. Downstream steps see a clean graph with the noisy branches
  already pruned.
- ✅ **Plan-time evaluation removal**: we eliminated `$step.eval*()` and other
  hooks that mutated the plan mid-build. Today, plan resolvers stay declarative;
  all decision making happens in step execution where it belongs, so the same
  plan can be safely reused for every compatible request.
- ✅ **Polymorphism convergence**: combined layer plans merge abstract-type
  branches back together before the next layer is planned. That keeps the
  mental model manageable: each layer still represents a single batch of work,
  even when unions or interfaces are involved.

Together these projects solidify the [“thinking in plans”](/grafast/flow) model:
describe your desired dataflow once, let Gra*fast* optimize it, and rely on the
engine to reuse that plan across every matching request.

<!-- truncate-->

Delivering those shifts meant rewriting plan resolvers to embrace the new unary
contracts, teaching the SQL layers to build queries at execution, and
validating the diagrams against real production workloads inside [PostGraphile
V5](https://postgraphile.org). The payoff is a planning engine that exposes the entire dataflow, keeps
resolution ergonomic, and still lets Gra*fast* squeeze out every possible
optimization.

## What does release candidate mean for Gra*fast*?

The runtime APIs, wire protocol, and behaviour have settled but the documentation
needs to catch up, and some TypeScript types are still rough. An RC gives us
the space to focus entirely on quality before stamping the final 1.0 release.

The teams running Gra*fast* in production have shipped upgrades for months without
regressions. The project is stable enough that you should not expect further breaking
changes to runtime behaviour. However, we will continue to refine TypeScript typings
during the RC window. Most of the changes will be improvements to inference and generics,
but they may require the occasional annotation tweak in your code. TSDoc comments are
also lagging behind; treat them as a helpful hint, not a contract, until we finish the
documentation refresh.

Now is the perfect moment to validate that the “[plans as dataflow](/grafast/flow)” approach
clicks for you: do the steps Gra*fast* produce line up with the dependencies you
expect? Does the separation between execution and output plan match how you
reason about your schema? Share your feedback in our [Discord](https://discord.gg/graphile).

## Documentation: where we need you

The code moved faster than the words that describe it. Parts of the docs are
out of date, others are missing, and a few contradict the behaviour you see in
practice. We need review, issue reports, and small patches. Your first-hand notes
about what is unclear are invaluable.

Feedback via [GitHub issues](https://github.com/graphile/crystal) or the
[Discord server](https://discord.gg/graphile) is hugely appreciated.

## Try Gra*fast* v1 today

Install the release candidate from npm, we are keeping it under the `@beta` tag to
make transition as smooth as possible:

```bash
yarn add grafast@beta
```

If you are integrating Gra*fast* outside of PostGraphile, start with the
updated examples in the repository and let us know what still feels rough. For
PostGraphile users, this RC is the same engine that powers the V5 release
candidate, so upgrading both together is the smoothest path.

## Sponsors make Gra*fast* possible

Gra*fast* exists thanks to the companies and individuals who fund our work.
Their backing lets us spend the time needed to invent, iterate, and polish the
engine you are using today. If Gra*fast* helps you ship faster or operate more
efficiently, please consider joining them at
[graphile.org/sponsor](https://graphile.org/sponsor).

<figure>

![Thank you](../static/img/news/thank-you.svg)

</figure>
