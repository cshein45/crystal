---
title: Grafast v1 reaches release candidate stage
description:
  Grafast v1 is functionally complete and powering production workloads, now
  we need your help to finish the docs ahead of the 1.0 final.
slug: 2025-10-16-grafast-v1-release-candidate
authors: [benjie, jem]
tags: [Release candidate]
hide_table_of_contents: false
toc_max_heading_level: 2
---

import styles from "@site/src/css/common.module.css";

<div className={styles.intro}>

The Gra*fast* v1.0 release candidate is now available. The engine has stabilized, the
epic milestones are complete, and the runtime has been hardened by more than a year of
production use through PostGraphile V5 and standalone adopters. All that
remains is to finish the documentation and tighten the TypeScript experience.

</div>

## From working group sketches to a stable execution engine

We debuted Gra*fast* in 2020 as an answer to the limits of resolver-driven
execution. The Gra*fast* working group helped us identify four epics that had
to be solved before we could release Version 1:

- ✅ **Global dependencies**: replace global dependencies so plan resolvers can
  rely on precise, single-value inputs.
- ✅ **Early exit controls**: use flags, preventing needless downstream work
  when a branch is no longer required.
- ✅ **Plan-time evaluation removal**: eliminate `$step.eval*()` and other brittle
  shortcuts, giving us safer, more predictable execution flows.
- ✅ **Polymorphism convergence**: introduce combined steps so abstract types
  stop exploding into exponential branches.

These epics also complete the mental model we now advocate in
[“Thinking in plans”](/grafast/flow): you describe the desired dataflow once,
Gra*fast* optimizes it, and reuses that plan safely across execution requests.
With unary dependencies tidied, branching controlled, and polymorphism tamed,
it is now straightforward to reason about how values flow through the graph.

<!-- truncate-->

Along the way we rewrote countless plan resolvers, improved SQL generation,
refined cache behaviour, and validated the architecture inside PostGraphile V5.
The result is a planning engine that delivers holistic visibility across a
GraphQL operation while still feeling ergonomic to write against.

## Why call it a release candidate now?

The runtime APIs, wire protocol, and behaviour have settled. The teams running
Gra*fast* in production have shipped upgrades for months without regressions.
We also know that the documentation needs to catch up, and that some TypeScript
types are still rough. An RC gives us the space to focus entirely on quality
before stamping the final 1.0.

You should not expect further breaking changes to runtime behaviour. However,
we will continue to refine TypeScript typings during the RC window. Most of the
changes will be improvements to inference and generics, but they may require
the occasional annotation tweak in your code. TSDoc comments are also lagging
behind; treat them as a helpful hint, not a contract, until we finish the doc
refresh.

Now is the perfect moment to validate that the “plans as dataflow” approach
clicks for you: do the steps Gra*fast* produces line up with the dependencies you
expect? Does the separation between execution and output plan match how you
reason about your schema? Tell us.

## Documentation: where we need you

- Read through the planners, step references, and tutorial content. Tell us
  where it is wrong or missing detail.
- Share recipes for multi-data-source plan resolvers so that others can learn
  from your patterns.
- Help us document the new combined-step APIs and the unary helper utilities.
- File issues when terminology disagrees with what you see in code.
- Treat plans as a reusable dataflow graph: each plan resolver contributes steps
  that describe how values move from inputs through unary dependencies and layer
  plans until they reach the output plan. Skim the refreshed
  [“Thinking in plans” overview](/grafast/flow), try mapping one of your own
  fields using that mindset, and tell us where the explanation still trips you
  up or leaves you guessing. Concrete anecdotes and suggested wording tweaks are
  incredibly valuable.

Feedback via [GitHub issues](https://github.com/graphile/crystal) or the
[Discord server](https://discord.gg/graphile) is hugely appreciated. Patches
are golden, but reproducible bug reports and annotated screenshots are just as
valuable.

## Try Gra*fast* v1 today

Grab the release candidate from npm, we are keeping under the `@beta` tag to
make transition as smooth as possible:

```bash
yarn add grafast@beta
```

If you are integrating Gra*fast* outside of PostGraphile, start with the
updated examples in the repository and let us know what still feels rough. For
PostGraphile users, this RC is the same engine that powers the V5 release
candidate, so upgrading both together is the smoothest path.

## Sponsors make Gra*fast* possible

Gra*fast* exists thanks to the companies and individuals who fund our work.
Their backing lets us spend the time needed to invent, iterate, and polish the
engine you are using today. If Gra*fast* helps you ship faster or operate more
efficiently, please consider joining them at
[graphile.org/sponsor](https://graphile.org/sponsor).

<figure>

![Thank you](../static/img/news/thank-you.svg)

</figure>
